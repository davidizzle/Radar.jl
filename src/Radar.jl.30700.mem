        - 
        - module Radar
        -     using Distributions
        -     using Random
        -     using Observables
        -     using LinearAlgebra
        -     using ..Parameters
        -     using ..Constants
        -     using ..Targets
        - 
        -     mutable struct DataCube <: AbstractArray{ComplexF64, 3}
        -         data::Array{ComplexF64, 3}
        -         rangeBins::Int
        -         nPulses::Int
        -         nChannels::Int
        -     end
        - 
        -     function DataCube(rangeBins::Int, nPulses::Int, nChannels::Int)
        -         # Initialize all to zeros
        -         @assert rangeBins > 0 "Number of range bins must be positive"
        -         @assert nPulses > 0 "Number of pulses must be positive"
        -         @assert nChannels > 0 "Number of channels must be positive"
        -         return DataCube(zeros(rangeBins, nPulses, nChannels), rangeBins, nPulses, nChannels)
        -     end
        - 
        -     Base.size(dc::DataCube) = size(dc.data) # Delegates to the internal array's size
        - 
        -     Base.getindex(dc::DataCube, i::Int, j::Int, k::Int) = getindex(dc.data, i, j, k)
        -     Base.getindex(dc::DataCube, I::Vararg{Int,N}) where N = getindex(dc.data, I...) # For arbitrary number of indices
        - 
        -     Base.setindex!(dc::DataCube, v, i::Int, j::Int, k::Int) = setindex!(dc.data, v, i, j, k)
        -     Base.setindex!(dc::DataCube, v, I::Vararg{Int,N}) where N = setindex!(dc.data, v, I...) # For arbitrary number of indices
        - 
        -     # Implement methods for StridedArray compatibility needed for FFTW In-Place
        -     Base.parent(dc::DataCube) = dc.data
        -     Base.parentindices(dc::DataCube) = map(Base.Slice, axes(dc.data)) # Or (Base.Slice(1:size(A,1)), Base.Slice(1:size(A,2)), Base.Slice(1:size(A,3)))
        -     Base.strides(dc::DataCube) = strides(dc.data)
        - 
        -     clear(dc::DataCube) = fill!(dc.data, ComplexF64(0.0))
        - 
        -     mutable struct pulseRadar
        -         datacube::DataCube
        -         carrierFrequency::Float64
        -         bandwidth::Float64
        -         samplingFrequency::Float64
        -         chirp::Vector{ComplexF64}
        -         matchedFilter::Vector{ComplexF64}
        -         dutyCycle::Float64
        -         # azimuth::Observable{Float64}
        -         azimuth::Float64
        -         elevation::Float64
        -         azimuthStep::Float64
        -         angularSpeed::Float64
        -         # For charting output
        -         echo::Vector{ComplexF64}
        -         compressedEcho::Vector{ComplexF64}
        -         dopplerEcho::AbstractMatrix{ComplexF64}
        -     end
        - 
        -     """ A simple pulse radar system that generates a chirp signal with linear frequency modulation, 
        -         sampling frequency of 5 MHz, and a carrier frequency of 3 GHz.
        -         Every range bin is then 60 m apart, and assuming a Radar coverage range of 240 km,
        -         the number of range bins by default is 4000.
        - 
        -     """
        -     function pulseRadar()
        - 
        -         coverageRange = Parameters.radarCoverageRange
        -         carrierFreq = Parameters.radarCarrierFrequency
        -         BW = Parameters.radarChirpBW
        -         samplingFreq = Parameters.radarSamplingFrequency
        -         dutyCycle = Parameters.radarDutyCycle / 100.0  # Convert percentage to fraction
        - 
        -         rangeBins = Int(floor(coverageRange / (Constants.lightSpeed / (2 * samplingFreq))))  # Number of range bins based on coverage range and sampling frequency
  1601223         dc = DataCube(rangeBins, Parameters.nPulsesPerBurst, Parameters.nChannels)
        -         chirpWindowLength = floor(Int, dutyCycle * rangeBins)
        0         chirpWindow = range(0, chirpWindowLength / samplingFreq, length = chirpWindowLength)
        - 
        -         # chirp = 3 .* exp.(im * (2 * π * carrierFreq * chirpWindow .+ π * BW / chirpWindowLength .* chirpWindow .^ 2))
    16254         chirp = 3 * exp.(im * π * BW / chirpWindow[end] * ( chirpWindow .- chirpWindow[end] / 2).^2)
    10775         matchedFilter = conj(reverse(chirp)) ./ norm(chirp, 2)
        - 
  3416021         pulseRadar(dc, carrierFreq, BW, samplingFreq, chirp, matchedFilter, dutyCycle, Parameters.radarInitialAzimuth,
        -          Parameters.radarInitialElevation, Parameters.radarAzimuthStep, Parameters.radarAngularVelocity,
        -          zeros(ComplexF64, rangeBins), zeros(ComplexF64, rangeBins), zeros(ComplexF64, rangeBins, Parameters.nPulsesPerBurst * 3))
        -     end
        - 
        - 
        -     ### RADAR PROCESSING CHAIN
        -     module RadarProcessingChain
        -         using FFTW
        -         using Distributions
        -         using Plots
        -         using Random
        -         using DSP
        -         using ..Radar
        -         using ...Targets
        -         using ...SwerlingModels
        -         using ...Parameters
        -         using ...Constants
        - 
        -         function calculateTargetEcho(target::Targets.Target, rangeBins::Int, az::Float64, fs::Float64, fc::Float64, chirpedSignal::Vector{ComplexF64})       
        -             
        -             # println("AZ = $az, Target AZ = $(target.azimuth), Δ = $(abs(az - target.azimuth))")
        0             if abs(az - target.azimuth) >= 0.5
        0                 return nothing  # No echo if target is outside the azimuth coverage
        -             end
        - 
        -             
        -             # Calculate the time delay based on the target's radial speed and distance
        0             delayTime = 2 * target.distance / Constants.lightSpeed
        0             delayRangeBins = round(Int, delayTime * fs)
        -             
        -             # Doppler frequency shift based on the target's radial speed
        0             t = (0:length(chirpedSignal)-1) / fs
        0             dopplerShift = 2 * target.radialSpeed / Constants.lightSpeed * fc
   549829             dopplerPhase = exp.(im .* 2 .* π .* dopplerShift .* t)
        -             
        -             # Calculate attenuation
     2432             attenuation = 1e10 * SwerlingModels.swerlingAmplitude(target.rcs, target.swerlingModel) / (target.distance^2 + 1e-6)
        -             
     3264             echo = chirpedSignal .* attenuation .* dopplerPhase
  5448885             paddedEcho = zeros(ComplexF64, rangeBins)
     8160             paddedEcho[1:length(echo)] .= echo  
        -             # plt = Plots.plot(abs.(circshift(paddedEcho, delayRangeBins)), title="Echo", xlabel="Bin", ylabel="|Amplitude|")
        -             # display(plt)  # Or `gui()` to force window display
        -             # Generate the echo signal with Doppler shift and noise
  5449141             return circshift(paddedEcho, delayRangeBins)
        -         end
        - 
        -         function calculateClutterEcho(rangeBins::Int, p::Int; strength=0.5, dopplerSpread=0.01)
133785162             taper = exp.(-range(0, rangeBins-1) ./ (rangeBins * 4))
        - 
267326714             clutter = strength * randn(ComplexF64, rangeBins) .* taper
267567220             phaseVel = 2π * dopplerSpread .* rand(rangeBins)
        0             clutter .*= exp.(im .* phaseVel .* p)
        - 
        0             return clutter
        -         end
        - 
        -         # const calculateClutterEcho = let
        -         #     clutter_buf = nothing
        -         #     taper = nothing
        -         #     phase_buf = nothing
        -         #     prev_N = 0  # track the size used to know when to reallocate
        - 
        -         #     function (rangeBins::Int, p::Int; strength=0.5, dopplerSpread=0.01)
        -         #         if clutter_buf === nothing || rangeBins != prev_N
        -         #             # (Re)initialize on first use or when size changes
        -         #             clutter_buf = Vector{ComplexF64}(undef, rangeBins)
        -         #             taper = exp.(-range(0, rangeBins - 1) ./ (rangeBins * 4))
        -         #             phase_buf = Vector{Float64}(undef, rangeBins)
        -         #             prev_N = rangeBins
        -         #         end
        - 
        -         #         randn!(clutter_buf)
        -         #         @. clutter_buf = strength * clutter_buf * taper
        -         #         rand!(phase_buf)
        -         #         @. phase_buf = 2π * dopplerSpread * phase_buf
        -         #         @. clutter_buf *= cis(phase_buf * p)
        - 
        -         #         return clutter_buf
        -         #     end
        -         # end
        - 
        -         function calculateTerrainMask(mask::Vector{ComplexF64}, az::Float64, samples::Int, fs::Float64)
        - 
        0             for element in Parameters.terrainOccludedVisibility
   320256                 if !(az in element[1])
        -                     continue
        -                 end
        -                 
        -                 # If we are in the azimuth range of the terrain occlusion
        0                 kmRange = element[2]
        0                 visibility = element[3]
        -                 
        0                 binsize = Constants.lightSpeed / (2 * fs)  # Range bin size in meters
        -                 
        -                 # Convert km range to range bins
        0                 startRange = first(kmRange) * 1000
        0                 endRange   = last(kmRange) * 1000
        - 
        0                 startBin = max(0, round(Int, startRange / binsize))
        0                 endBin = min(samples, round(Int, endRange / binsize))
        - 
        0                 mask[startBin:endBin] .= visibility  # Set visibility in the range bins
        0             end
        - 
        0             return mask
        -         end
        - 
        -         """    Function to process the radar echo signal using pulse compression.
        -         It applies a matched filter to the echo signal to enhance the target detection.
        -         Parameters:
        -         - r: pulseRadar object containing radar parameters and chirp signal.
        -         - echo: Vector of ComplexF64 representing the received echo signal.
        -         Returns:
        -         - Compressed echo signal as a Vector of ComplexF64.
        -         """
        -         function pulseCompression(echo::Vector{ComplexF64}, matchedFilter::Vector{ComplexF64})
        -             # Pad matched filter
        0             N = length(echo)
240589322             paddedFilter = vcat(zeros(ComplexF64, N - length(matchedFilter)), matchedFilter)
        -             # @show size(echo), size(paddedFilter)
267333530             output = fft(echo) .* fft(paddedFilter)
        0             return ifft(output)
        -             
        -             # # Apply matched filter to the echo signal
        -             # res = conv(echo, matchedFilter)
        - 
        -             # # Normalize the compressed echo
        -             # res ./= maximum(abs.(res))
        - 
        -             # # Center-trim
        -             # N = length(echo)
        -             # halfLength = length(matchedFilter) ÷ 2
        -             # res[halfLength:halfLength + N - 1]
        -         end
        - 
        -         function dopplerProcessing!(compressedEchoes::AbstractMatrix{ComplexF64})
        -             # FFT along the columns
        0             fft!(compressedEchoes, 2)  # FFT to process the echo in frequency domain
        0             compressedEchoes .= conj.(compressedEchoes) ./ sqrt(Parameters.nPulsesPerBurst)  # Renormalize after gain
        - 
        -             # Out-of-place circshift along rows (1st dim)
        0             shift_amount = size(compressedEchoes, 1) ÷ 2
294607782             compressedEchoes .= circshift(compressedEchoes, (shift_amount, 0))
        -         end
        - 
        -         """
        -         Performs Cell-Averaging CFAR on a 2D matrix (e.g., range-Doppler map).
        - 
        -         # Arguments:
        -         - data: 2D matrix (ComplexF64 or Real)
        -         - guard: number of guard cells (per side)
        -         - ref: number of reference cells (per side)
        -         - K: scaling factor (e.g., 1.4 for 13 reference cells)
        - 
        -         # Returns:
        -         - detections: BitMatrix of size(data), where true = detection
        -         """
        -         function caCFAR(data::AbstractMatrix; guard::Int=1, ref::Int=4, K::Float64=1.4)
        0             rows, cols = size(data)
        0             detections = falses(rows, cols)
        - 
        -             # Work on magnitude
 36832659             mag = abs.(data)
        - 
        0             totalWindow = guard + ref
        - 
        0             for r in (1 + totalWindow):(rows - totalWindow)
        0                 for c in (1 + totalWindow):(cols - totalWindow)
        -                     # Define reference window
        0                     rStart, rEnd = r - totalWindow, r + totalWindow
        0                     cStart, cEnd = c - totalWindow, c + totalWindow
        - 
        -                     # Exclude guard + CUT window
        0                     rGuardStart, rGuardEnd = r - guard, r + guard
        0                     cGuardStart, cGuardEnd = c - guard, c + guard
        - 
        -                     # Get reference cells
        0                     window = mag[rStart:rEnd, cStart:cEnd]
        0                     window[rGuardStart - rStart + 1 : rGuardEnd - rStart + 1,
        -                         cGuardStart - cStart + 1 : cGuardEnd - cStart + 1] .= NaN
        - 
        -                     # Compute threshold
        0                     noise = mean(skipmissing(window))
        0                     threshold = K * noise
        - 
        0                     if mag[r, c] > threshold
        0                         detections[r, c] = true
        -                     end
        0                 end
        0             end
        - 
        0             return detections
        -         end
        - 
        -         function processingRoutine(r::Radar.pulseRadar, targets::Vector{Targets.Target})
        - 
        -             # r.datacube.data = zeros(ComplexF64, r.datacube.rangeBins, r.datacube.nPulses, r.datacube.nPulses) # Clear the data cube before processing
        0             Radar.clear(r.datacube)
        0             for channel in 1:r.datacube.nChannels
        0                 for pulse in 1:r.datacube.nPulses
        -                     
        -                     # Simulate listening for echoes  
        -                     # 2 ms == ~300km coverage range
        -                     # Radars can actually be smart and listen for residual echoes in following pulses.
        -                     # However, for now, this is beyond the scope of this simple tool. 2 ms is a dense enough
        -                     # grid to scan for targets, i.e. ~ 0.06 deg at 12 seconds per revolution
        -                     # TODO: Listen for residual echoes, cut listening time by Npulses
   333488                     sleep(2e-3) 
        -                     # println("-----------------RUN-----------------")
        -                     # println(std(r.datacube[:, pulse, channel]))
267329674                     r.datacube[:, pulse, channel] .= craftComplexEcho!(r, r.datacube[:, pulse, channel], targets, pulse)
        0                     r.echo .= @view r.datacube[:, pulse, channel]  # Update echo for charting
        -                     # println(std(r.datacube[:, pulse, channel]))
        -                     # println(r.datacubbe[:, pulse, channel])
        -                     # FAST-TIME: Apply pulse compression
267327258                     r.datacube[:, pulse, channel] .= pulseCompression(r.datacube[:, pulse, channel], r.matchedFilter)
        0                     r.compressedEcho .= @view r.datacube[:, pulse, channel]  # Update compressed echo for charting
        -                     # println(std(r.datacube[:, pulse, channel]))
        -                     # println(r.datacube[:, pulse, channel])
        - 
        0                 end
        0             end
        - 
        -             # # FAST-TIME: Apply pulse compression
        -             # compressedEcho = pulseCompression!(r.datacube[], r.matchedFilter)
        - 
        -             # SLOW-TIME: Apply Doppler processing
 73658227             r.dopplerEcho .= hcat(r.datacube.data[:, :, 1], zeros(r.datacube.rangeBins, r.datacube.nPulses * 2))  # Matrix of Doppler data
        0             dopplerProcessing!(r.dopplerEcho)
        0             r.datacube[:, :, 1] .= dopplerProcessing!(r.datacube[:, :, 1])
        -             # if maximum(abs.(r.datacube[:, :, 1])) > 30
        -             #     println("Max Doppler data: $(maximum(abs.(r.datacube[:, :, 1])))")
        -             # end
        -   
        0             detections = caCFAR(r.datacube[:, :, 1])
        - 
        -             # TODO: Implement monopulse with added channels
        - 
        0             return detections
        -         end
        - 
        -         function craftComplexEcho!(r::Radar.pulseRadar, out::Vector{ComplexF64}, targets::Vector{Targets.Target}, pulseNum::Int)
        -             
        -             # Preallocate auxiliary vectors
267336330             mask = zeros(ComplexF64, r.datacube.rangeBins)
267246586             clutter = zeros(ComplexF64, r.datacube.rangeBins)
        - 
        0             for target in targets
        -                 # Calculate echo for each target
        0                 targetEcho = calculateTargetEcho(Targets.toPolar(target), r.datacube.rangeBins, r.azimuth, r.samplingFrequency, r.carrierFrequency, r.chirp) 
        0                 if targetEcho !== nothing
        0                     out .+= targetEcho  # Add the echo to the output
        -                 end
        0             end
        - 
        -             # Add clutter 
        0             out .+= calculateClutterEcho(r.datacube.rangeBins, pulseNum)
        -             # Add terrain mask
        0             out .*= calculateTerrainMask(mask, r.azimuth, r.datacube.rangeBins, r.samplingFrequency)
        - 
        -             # Add noise to the echo
        -             # out .+= randn(ComplexF64, r.datacube.rangeBins) * 0.1  # Add some noise
        0             noisyBackground = rand(Normal(0, 1), r.datacube.rangeBins) # Simulated noise in the background
        0             out .+= noisyBackground  # Add noise to the echo
        -         end
        -     end
        - 
        -        
      624     function runRadar(
        -         radar::Radar.pulseRadar,
        -         targets::Vector{Targets.Target};
        -         fps=60.0,
        -         maxRange=5.0,
        -         clockwise=true)
        -         @async begin
        -             
        -             dt = 1 / fps
        0             lastUpdateTime = time()
        0             while true
        -                 # Time elapsed update
        0                 currentTime = time()
        0                 timeElapsed = currentTime - lastUpdateTime
        -                 lastUpdateTime = currentTime
        -                 
        -                 # Azimuth spanned update
        0                 deltaAz = timeElapsed * radar.angularSpeed
        0                 deltaAz = clockwise ? deltaAz : -deltaAz
        0                 radar.azimuth = mod(radar.azimuth + deltaAz, 360)
        - 
        -                 # beamPoints[] = [beamPoints[][1], newEnd]
        -                 # beamPoints[][2] = newEnd
        -                 # Update detection routine
    60192                 @async begin
        -                     try
        0                         RadarProcessingChain.processingRoutine(radar, targets)
        -                     catch e
        0                         @error "Radar processing failed!" exception=(e, catch_backtrace())
        -                     end
        -                 end
        -                 # sleep(dt)
        -                 # This is too frequent, we ideally want to only reliqnquish control when we are not updating the UI
        -                 # yield() 
        -                 # Workaround: sleep a fine-tuned amount
    13840                 sleep(1e-2)
        -             end
        -         end
        -     end
        - 
        - end 
        - 
