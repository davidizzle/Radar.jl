        - 
        - 
    73224 module Targets
        - 
        -     include("swerling.jl")
        -     using .SwerlingModels
        - 
        -     abstract type Target end
        - 
        -     mutable struct PolarTarget <: Target
        -         distance::Float64  # Distance to the target in meters
        -         azimuth::Float64  # Azimuth angle of the target in radians
        -         radialSpeed::Float64  # Radial speed of the target in m/s, +Approaching, -Receding
        -         tangentialSpeed::Float64  # Tangential speed of the target in m/s, +CW, -CCW
        -         swerlingModel::Symbol  # Swerling model type
        -         rcs::Float64  # Radar Cross Section (RCS) in square meters
        -         lastUpdateTime::Float64  # Last update time for the target
        -         status::Symbol  # Status of the target, e.g., :friend, :foe, :unknown
        -     end
        -     
        -     function PolarTarget(distance::Float64, azimuth::Float64, radialSpeed::Float64, tangentialSpeed::Float64; swerlingModel::Symbol = :Swerling0, rcs::Float64 = 1.0, status = :unknown)
        -         @assert distance >= 0 "Distance must be non-negative"
        -         # @assert radialSpeed >= 0 "Radial speed must be non-negative"
        -         @assert azimuth >= 0 && azimuth < 2π "Azimuth must be in the range [0, 2π)"
        -         @assert swerlingModel in [:Swerling0, :Swerling1, :Swerling2, :Swerling3, :Swerling4] "Unsupported Swerling model: $swerlingModel"
        -         @assert rcs >= 0 "RCS must be non-negative"
        -         
        -         return PolarTarget(distance, azimuth, radialSpeed, tangentialSpeed, swerlingModel, rcs, time(), status)
        -     end
        -     
        -     mutable struct CartesianTarget <: Target
        -         x::Float64  # X coordinate of the target in meters
        -         y::Float64  # Y coordinate of the target in meters
        -         xVel::Float64  # Velocity along X axis
        -         yVel::Float64  # Velocity along Y axis
        -         swerlingModel::Symbol  # Swerling model type
        -         rcs::Float64  # Radar Cross Section (RCS) in square meters
        -         lastUpdateTime::Float64  # Last update time for the target
        -         status::Symbol  # Status of the target, e.g., :friend, :foe, :unknown
        -     end
        -     
        -     function CartesianTarget(x::Float64, y::Float64, xVel::Float64, yVel::Float64; swerlingModel::Symbol = :Swerling0, rcs::Float64 = 1.0, status = :unknown)
      640         @assert swerlingModel in [:Swerling0, :Swerling1, :Swerling2, :Swerling3, :Swerling4] "Unsupported Swerling model: $swerlingModel"
        0         @assert rcs >= 0 "RCS must be non-negative"
        - 
      800         return CartesianTarget(x, y, xVel, yVel, swerlingModel, rcs, time(), status)
        -     end
        - 
        -     function updatePosition(target::PolarTarget)
        -         # Update the target's position based on its radial speed and the current time
        -         currentTime = time()
        -         timeElapsed = currentTime - target.lastUpdateTime
        -         target.distance -= target.radialSpeed * timeElapsed
        -         target.lastUpdateTime = currentTime
        - 
        -         target.azimuth *= 2π / 360  # Convert azimuth to radians
        -         x = target.distance * cos(target.azimuth)
        -         y = target.distance * sin(target.azimuth)
        -         vx = target.radialSpeed * cos(target.azimuth) - target.tangentialSpeed * sin(target.azimuth)
        -         vy = target.radialSpeed * sin(target.azimuth) + target.tangentialSpeed * cos(target.azimuth)
        - 
        -         x += vx * timeElapsed
        -         y += vy * timeElapsed
        - 
        -         target.distance = sqrt(x^2 + y^2)
        -         target.azimuth = atan(y, x) 
        -         target.radialSpeed = vx * cos(target.azimuth) + vy * sin(target.azimuth)
        -         target.tangentialSpeed = -vx * sin(target.azimuth) + vy * cos(target.azimuth)
        -         target.azimuth *= 360 / (2π)  # Convert back to degrees
        - 
        -         # Ensure distance does not go negative
        -         if target.distance < 0
        -             target.radialSpeed = -target.radialSpeed  # Reverse direction if distance goes negative
        -         end
        -     end
        - 
        -     function updatePosition(target::CartesianTarget)
        -         # Update the target's position based on its velocities
        -         currentTime = time()
        -         timeElapsed = currentTime - target.lastUpdateTime
        -         target.lastUpdateTime = currentTime
        -         
        -         target.x += target.xVel * timeElapsed
        -         target.y += target.yVel * timeElapsed
        -     end
        - 
        -     function switchTarget!(target::PolarTarget)
        -         target.azimuth *= 2π / 360  # Convert azimuth to radians
        -         x = target.distance * cos(target.azimuth)
        -         y = target.distance * sin(target.azimuth)
        -         vx = target.radialSpeed * cos(target.azimuth) - target.tangentialSpeed * sin(target.azimuth)
        -         vy = target.radialSpeed * sin(target.azimuth) + target.tangentialSpeed * cos(target.azimuth)
        -         target = CartesianTarget(x, y, vx, vy, target.swerlingModel, target.rcs, target.lastUpdateTime, target.status)
        -     end
        - 
        -     function switchTarget!(target::CartesianTarget)
        0         distance = sqrt(target.x^2 + target.y^2)
        0         azimuth = atan(target.y, target.x)
        0         radialSpeed = target.xVel * cos(azimuth) + target.yVel * sin(azimuth)
        0         tangentialSpeed = -target.xVel * sin(azimuth) + target.yVel * cos(azimuth)
        0         azimuth *= 360 / (2π)  # Convert back to degrees
  2001600         target = PolarTarget(distance, azimuth, radialSpeed, tangentialSpeed, target.swerlingModel, target.rcs, target.lastUpdateTime, target.status)
        -     end
        - 
        -     function toPolar(target::CartesianTarget)
        -         return switchTarget!(target)
        -     end
        -     function toPolar(target::PolarTarget)
        -         return target
        -     end
        -     
        -     function toCartesian(target::CartesianTarget)
        -         return target
        -     end
        -     function toCartesian(target::PolarTarget)
        -         return switchTarget!(target)
        -     end
        - 
        - end
